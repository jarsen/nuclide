'use babel';
/* @flow */

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

import yaml from 'js-yaml';
import fsPromise from '../../../commons-node/fsPromise';

type LlbuildYamlInfo = {
  sources: Array<string>;
  otherArgs: Array<string>;
};

/**
 * SourceKit's capability to provide type information and autocompletion
 * suggestions is limited without the proper compiler arguments necessary
 * to compile the Swift code being looked at. This returns those arguments,
 * by finding the most appropriate llbuild YAML generated by SwiftPM.
 */
export async function compilerArgsForFile(
  filePath: string,
  yamlFilePath: string,
): Promise<string> {
  const yamlInfos: Array<LlbuildYamlInfo> = await readLlbuildYamlFile(yamlFilePath);
  for (var yamlInfoIndex = 0; yamlInfoIndex < yamlInfos.length; ++yamlInfoIndex) {
    const yamlInfo = yamlInfos[yamlInfoIndex];
    for (var sourceIndex = 0; sourceIndex < yamlInfo.sources.length; ++sourceIndex) {
      const source = yamlInfo.sources[sourceIndex];
      if (source === filePath) {
        return yamlInfo.otherArgs.concat(yamlInfo.sources).join(' ');
      }
    }
  }

  return '';
}

async function readLlbuildYamlFile(
  path: string,
): Promise<Array<LlbuildYamlInfo>> {
  const data = await fsPromise.readFile(path, 'utf8');
  let llbuildYaml;
  try {
    llbuildYaml = yaml.safeLoad(data);
  } catch (e) {
    return new Promise((resolve, reject) => {
      resolve([]);
    });
  }

  let yamlInfos = [];
  for (const command in llbuildYaml.commands) {
    if (!command.endsWith('.module>')) {
      continue;
    }
    const llbuildCommand = llbuildYaml.commands[command];
    yamlInfos.push({
      sources: llbuildCommand.sources,
      otherArgs: llbuildCommand['other-args'],
    });
  }

  return yamlInfos;
}
